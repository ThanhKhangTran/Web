"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const process = require("process");
const debugModule = require("debug");
const uuid = require("uuid/v4");
const constants_1 = require("./util/constants");
const amqp_common_1 = require("./amqp-common");
const managementClient_1 = require("./managementClient");
const rhea_promise_1 = require("./rhea-promise");
const constants_2 = require("./amqp-common/util/constants");
const debug = debugModule("azure:event-hubs:connectionContext");
var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property {string} userAgent The user agent string for the event hub client. Constant value: "/js-event-hubs".
     */
    ConnectionContext.userAgent = "/js-event-hubs";
    function create(config, options) {
        if (!options)
            options = {};
        amqp_common_1.ConnectionConfig.validate(config, { isEntityPathRequired: true });
        const packageVersion = constants_1.packageJsonInfo.version;
        const connectionOptions = {
            transport: amqp_common_1.Constants.TLS,
            host: config.host,
            hostname: config.host,
            username: config.sharedAccessKeyName,
            port: 5671,
            reconnect: false,
            properties: {
                product: "MSJSClient",
                version: packageVersion,
                platform: `(${os.arch()}-${os.type()}-${os.release()})`,
                framework: `Node/${process.version}`,
                "user-agent": ConnectionContext.userAgent
            }
        };
        const connection = new rhea_promise_1.Connection(connectionOptions);
        const connectionLock = `${amqp_common_1.Constants.establishConnection}-${uuid()}`;
        const connectionContext = {
            wasConnectionCloseCalled: false,
            connectionLock: connectionLock,
            negotiateClaimLock: `${amqp_common_1.Constants.negotiateClaim}-${uuid()}`,
            connection: connection,
            connectionId: connection.id,
            cbsSession: new amqp_common_1.CbsClient(connection, connectionLock),
            config: config,
            tokenProvider: options.tokenProvider ||
                new amqp_common_1.SasTokenProvider(config.endpoint, config.sharedAccessKeyName, config.sharedAccessKey),
            senders: {},
            receivers: {},
            dataTransformer: options.dataTransformer || new amqp_common_1.DefaultDataTransformer()
        };
        const mOptions = {
            address: options.managementSessionAddress,
            audience: options.managementSessionAudience
        };
        connectionContext.managementSession = new managementClient_1.ManagementClient(connectionContext, mOptions);
        // register handlers on the connection.
        const onConnectionOpen = (context) => {
            connectionContext.wasConnectionCloseCalled = false;
            debug("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        connectionContext.connection.registerHandler(rhea_promise_1.ConnectionEvents.connectionOpen, onConnectionOpen);
        const disconnected = async (context) => {
            connectionContext.connection.removeHandler(rhea_promise_1.ConnectionEvents.connectionOpen, onConnectionOpen);
            const connectionError = context.connection && context.connection.error
                ? context.connection.error
                : context.error ? context.error : undefined;
            if (connectionError) {
                debug("[%s] Error occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
            }
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was atleast one sender/receiver link on the connection before it went down.
            if (!connectionContext.wasConnectionCloseCalled &&
                (Object.keys(connectionContext.senders).length) ||
                Object.keys(connectionContext.receivers).length) {
                debug("[%s] connection.close() was not called from the sdk and there were some " +
                    "sender or receiver links or both. We should reconnect.", connectionContext.connection.id);
                await amqp_common_1.delay(constants_2.connectionReconnectDelay);
                // reconnect senders if any
                for (const sender of Object.values(connectionContext.senders)) {
                    debug("[%s] calling detached on sender '%s' with address '%s'.", connectionContext.connection.id, sender.name, sender.address);
                    sender.detached();
                }
                // reconnect receivers if any
                for (const receiver of Object.values(connectionContext.receivers)) {
                    debug("[%s] calling detached on receiver '%s' with address '%s'.", connectionContext.connection.id, receiver.name, receiver.address);
                    receiver.detached();
                }
            }
        };
        connectionContext.connection.registerHandler(rhea_promise_1.ConnectionEvents.disconnected, disconnected);
        debug("Created connection context: %O", connectionContext);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext = exports.ConnectionContext || (exports.ConnectionContext = {}));
//# sourceMappingURL=connectionContext.js.map