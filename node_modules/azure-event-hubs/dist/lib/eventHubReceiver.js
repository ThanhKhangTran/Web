"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const debugModule = require("debug");
const uuid = require("uuid/v4");
const rhea_promise_1 = require("./rhea-promise");
const amqp_common_1 = require("./amqp-common");
const _1 = require(".");
const linkEntity_1 = require("./linkEntity");
const eventPosition_1 = require("./eventPosition");
const debug = debugModule("azure:event-hubs:receiver");
/**
 * Describes the EventHubReceiver that will receive event data from EventHub.
 * @class EventHubReceiver
 */
class EventHubReceiver extends linkEntity_1.LinkEntity {
    /**
     * Instantiate a new receiver from the AMQP `Receiver`. Used by `EventHubClient`.
     *
     * @constructor
     * @param {EventHubClient} client                            The EventHub client.
     * @param {string} partitionId                               Partition ID from which to receive.
     * @param {ReceiveOptions} [options]                         Receiver options.
     */
    constructor(context, partitionId, options) {
        super(context, { partitionId: partitionId, name: options ? options.name : undefined });
        /**
         * @property {number} [prefetchCount] The number of messages that the receiver can fetch/receive
         * initially. Defaults to 1000.
         */
        this.prefetchCount = amqp_common_1.Constants.defaultPrefetchCount;
        /**
         * @property {boolean} receiverRuntimeMetricEnabled Indicates whether receiver runtime metric
         * is enabled. Default: false.
         */
        this.receiverRuntimeMetricEnabled = false;
        if (!options)
            options = {};
        this.consumerGroup = options.consumerGroup ? options.consumerGroup : amqp_common_1.Constants.defaultConsumerGroup;
        this.address = `${this._context.config.entityPath}/ConsumerGroups/${this.consumerGroup}/Partitions/${this.partitionId}`;
        this.audience = `${this._context.config.endpoint}${this.address}`;
        this.prefetchCount = options.prefetchCount != undefined ? options.prefetchCount : amqp_common_1.Constants.defaultPrefetchCount;
        this.epoch = options.epoch;
        this.identifier = options.identifier;
        this.options = options;
        this.receiverRuntimeMetricEnabled = options.enableReceiverRuntimeMetric || false;
        this.runtimeInfo = {
            partitionId: `${partitionId}`
        };
        this._checkpoint = {
            enqueuedTimeUtc: new Date(),
            offset: "0",
            sequenceNumber: -1
        };
        this._onAmqpMessage = (context) => {
            const evData = _1.EventData.fromAmqpMessage(context.message);
            evData.body = this._context.dataTransformer.decode(context.message.body);
            this._checkpoint = {
                enqueuedTimeUtc: evData.enqueuedTimeUtc,
                offset: evData.offset,
                sequenceNumber: evData.sequenceNumber
            };
            if (this.receiverRuntimeMetricEnabled && evData) {
                this.runtimeInfo.lastSequenceNumber = evData.lastSequenceNumber;
                this.runtimeInfo.lastEnqueuedTimeUtc = evData.lastEnqueuedTime;
                this.runtimeInfo.lastEnqueuedOffset = evData.lastEnqueuedOffset;
                this.runtimeInfo.retrievalTime = evData.retrievalTime;
                debug("[%s] RuntimeInfo of Receiver '%s' is %O", this._context.connectionId, this.name, this.runtimeInfo);
            }
            this._onMessage(evData);
        };
        this._onAmqpError = (context) => {
            const receiverError = context.receiver && context.receiver.error;
            const sessionError = context.session.error;
            if (receiverError) {
                const ehError = amqp_common_1.translate(context.receiver.error);
                debug("[%s] An error occurred for Receiver '%s': %O.", this._context.connectionId, this.name, ehError);
                this._onError(ehError);
            }
            else if (sessionError) {
                const ehError = amqp_common_1.translate(context.receiver.error);
                debug("[%s] An error occurred on the session for Receiver '%s': %O.", this._context.connectionId, this.name, ehError);
                this._onError(ehError);
            }
        };
        this._onAmqpClose = async (context) => {
            const receiverError = context.receiver && context.receiver.error;
            const sessionError = context.session.error;
            if (receiverError) {
                debug("[%s] 'receiver_close' event occurred. The associated error is: %O", this._context.connectionId, receiverError);
            }
            else if (sessionError) {
                debug("[%s] 'session_close' event occurred for receiver '%s'. The associated error is: %O", this._context.connectionId, this.name, sessionError);
            }
            await this.detached(receiverError || sessionError);
        };
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @param {AmqpError | Error} [receiverError] The receiver error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    async detached(receiverError) {
        let shouldReopen = false;
        if (receiverError && this._context.receivers[this.name]) {
            const translatedError = amqp_common_1.translate(receiverError);
            if (translatedError.retryable) {
                shouldReopen = true;
            }
        }
        else if (this._context.receivers[this.name]) {
            shouldReopen = true;
            debug("[%s] close() method of Receiver '%s' with address '%s' was not called. " +
                "There was no accompanying error as well. This is a candidate for re-establishing " +
                "the sender link.", this._context.connectionId, this.name, this.address);
        }
        if (shouldReopen) {
            const rcvrOptions = {
                onMessage: this._onAmqpMessage,
                onError: this._onAmqpError,
                onClose: this._onAmqpClose,
                newName: true // provide a new name to the link while re-connecting it. This ensures that
                // the service does not send an error stating that the link is still open.
            };
            // reconnect the receiver link with sequenceNumber of the last received message as the offset
            // if messages were received by the receiver before it got disconnected.
            if (this._checkpoint.sequenceNumber > -1) {
                rcvrOptions.eventPosition = eventPosition_1.EventPosition.fromSequenceNumber(this._checkpoint.sequenceNumber);
            }
            const options = this._createReceiverOptions(rcvrOptions);
            // shall retry 3 times at an interval of 15 seconds and bail out.
            await amqp_common_1.retry(() => this._init(options));
        }
    }
    /**
     * Closes the underlying AMQP receiver.
     * @returns {Promise<void>}
     */
    async close() {
        if (this._receiver) {
            try {
                const receiverLink = this._receiver;
                this._receiver = undefined;
                delete this._context.receivers[this.name];
                clearTimeout(this._tokenRenewalTimer);
                debug("[%s] Deleted the receiver '%s' from the client cache.", this._context.connectionId, this.name);
                await receiverLink.close();
                debug("[%s] Receiver '%s', has been closed.", this._context.connectionId, this.name);
            }
            catch (err) {
                debug("An error occurred while closing the receiver %s %O", this.name, amqp_common_1.translate(err));
            }
        }
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        debug("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @returns {Promise<void>}
     */
    async _init(options) {
        try {
            if (!this.isOpen()) {
                await this._negotiateClaim();
                if (!options) {
                    options = this._createReceiverOptions({
                        onMessage: this._onAmqpMessage,
                        onError: this._onAmqpError,
                        onClose: this._onAmqpClose
                    });
                }
                debug("[%s] Trying to create receiver '%s' with options %O", this._context.connectionId, this.name, options);
                this._receiver = await this._context.connection.createReceiver(options);
                this._receiver.registerSessionHandler(rhea_promise_1.SessionEvents.sessionError, options.onError);
                this._receiver.registerSessionHandler(rhea_promise_1.SessionEvents.sessionClose, options.onClose);
                debug("Promise to create the receiver resolved. Created receiver with name: ", this.name);
                debug("[%s] Receiver '%s' created with receiver options: %O", this._context.connectionId, this.name, options);
                // It is possible for someone to close the receiver and then start it again.
                // Thus make sure that the receiver is present in the client cache.
                if (!this._context.receivers[this.name])
                    this._context.receivers[this.name] = this;
                await this._ensureTokenRenewal();
            }
        }
        catch (err) {
            err = amqp_common_1.translate(err);
            debug("[%s] An error occured while creating the receiver '%s': %O", this._context.connectionId, this.name, err);
            throw err;
        }
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     */
    _createReceiverOptions(options) {
        if (options.newName)
            this.name = `${uuid()}`;
        const rcvrOptions = {
            name: this.name,
            autoaccept: true,
            source: {
                address: this.address
            },
            credit_window: this.prefetchCount,
            onMessage: options.onMessage || this._onAmqpMessage,
            onError: options.onError || this._onAmqpError,
            onClose: options.onClose || this._onAmqpClose
        };
        if (this.epoch !== undefined && this.epoch !== null) {
            if (!rcvrOptions.properties)
                rcvrOptions.properties = {};
            rcvrOptions.properties[amqp_common_1.Constants.attachEpoch] = rhea_promise_1.types.wrap_long(this.epoch);
        }
        if (this.identifier) {
            if (!rcvrOptions.properties)
                rcvrOptions.properties = {};
            rcvrOptions.properties[amqp_common_1.Constants.receiverIdentifierName] = this.identifier;
        }
        if (this.receiverRuntimeMetricEnabled) {
            rcvrOptions.desired_capabilities = amqp_common_1.Constants.enableReceiverRuntimeMetricName;
        }
        const eventPosition = options.eventPosition || this.options.eventPosition;
        if (eventPosition) {
            // Set filter on the receiver if event position is specified.
            const filterClause = eventPosition.getExpression();
            if (filterClause) {
                rcvrOptions.source.filter = {
                    "apache.org:selector-filter:string": rhea_promise_1.types.wrap_described(filterClause, 0x468C00000004)
                };
            }
        }
        return rcvrOptions;
    }
}
exports.EventHubReceiver = EventHubReceiver;
//# sourceMappingURL=eventHubReceiver.js.map