"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const debugModule = require("debug");
const receiver_1 = require("./receiver");
const sender_1 = require("./sender");
const _1 = require(".");
const debug = debugModule("rhea-promise:session");
class Session {
    constructor(connection, session) {
        this._connection = connection;
        this._session = session;
    }
    get connection() {
        return this._connection;
    }
    get outgoing() {
        return this._session.outgoing;
    }
    isOpen() {
        let result = false;
        if (this._connection.isOpen() && this._session.is_open()) {
            result = true;
        }
        return result;
    }
    remove() {
        if (this._session) {
            this._session.remove();
        }
    }
    begin() {
        if (this._session) {
            this._session.begin();
        }
    }
    /**
     * Closes the amqp session.
     * @return {Promise<void>} Promise<void>
     * - **Resolves** the promise when rhea emits the "session_close" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
     * to close an amqp session.
     */
    close() {
        return new Promise((resolve, reject) => {
            if (this.isOpen()) {
                const onClose = (context) => {
                    this._session.removeListener("session_close", onClose);
                    process.nextTick(() => {
                        debug("Resolving the promise as the amqp session has been closed.");
                        resolve();
                    });
                };
                const onError = (context) => {
                    this._session.removeListener("session_error", onError);
                    debug(`Error occurred while closing amqp session.`, context.session.error);
                    reject(context.session.error);
                };
                this._session.once("session_close", onClose);
                this._session.once("session_error", onError);
                this._session.close();
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Creates an amqp receiver on this session.
     * @param {Session} session The amqp session object on which the receiver link needs to be established.
     * @param {ReceiverOptions} [options] Options that can be provided while creating an amqp receiver.
     * @return {Promise<Receiver>} Promise<Receiver>
     * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
     * to create an amqp receiver.
     */
    createReceiver(options) {
        if (options &&
            ((options.onMessage && !options.onError) || (options.onError && !options.onMessage))) {
            throw new Error("Both onMessage and onError handlers must be provided if one of " +
                "them is provided.");
        }
        const handlersProvided = options && options.onMessage ? true : false;
        return new Promise((resolve, reject) => {
            const rheaReceiver = this._session.attach_receiver(options);
            const receiver = new receiver_1.Receiver(this, rheaReceiver, options);
            let onOpen;
            let onClose;
            if (handlersProvided) {
                rheaReceiver.on(_1.ReceiverEvents.message, options.onMessage);
                rheaReceiver.on(_1.ReceiverEvents.receiverError, options.onError);
            }
            if (options && options.onClose) {
                rheaReceiver.on(_1.ReceiverEvents.receiverClose, options.onClose);
            }
            const removeListeners = () => {
                rheaReceiver.removeListener("receiver_open", onOpen);
                rheaReceiver.removeListener("receiver_close", onClose);
            };
            onOpen = (context) => {
                removeListeners();
                process.nextTick(() => {
                    debug(`Resolving the promise with amqp receiver "${rheaReceiver.name}".`);
                    resolve(receiver);
                });
            };
            onClose = (context) => {
                removeListeners();
                debug(`Error occurred while creating a receiver over amqp connection.`, context.receiver.error);
                reject(context.receiver.error);
            };
            rheaReceiver.once("receiver_open", onOpen);
            rheaReceiver.once("receiver_close", onClose);
        });
    }
    /**
     * Creates an amqp sender on this session.
     * @param {SenderOptions} [options] Options that can be provided while creating an amqp sender.
     * @return {Promise<Sender>} Promise<Sender>
     * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
     * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
     * to create an amqp sender.
     */
    createSender(options) {
        return new Promise((resolve, reject) => {
            const rheaSender = this._session.attach_sender(options);
            const sender = new sender_1.Sender(this, rheaSender, options);
            let onSendable;
            let onClose;
            if (options) {
                if (options.onError) {
                    rheaSender.on(_1.SenderEvents.senderError, options.onError);
                }
                if (options.onClose) {
                    rheaSender.on(_1.SenderEvents.senderClose, options.onClose);
                }
                if (options.onAccepted) {
                    rheaSender.on(_1.SenderEvents.accepted, options.onAccepted);
                }
                if (options.onRejected) {
                    rheaSender.on(_1.SenderEvents.rejected, options.onRejected);
                }
                if (options.onReleased) {
                    rheaSender.on(_1.SenderEvents.released, options.onReleased);
                }
                if (options.onModified) {
                    rheaSender.on("modified", options.onModified);
                }
            }
            const removeListeners = () => {
                rheaSender.removeListener(_1.SenderEvents.senderOpen, onSendable);
                rheaSender.removeListener(_1.SenderEvents.senderClose, onClose);
            };
            onSendable = (context) => {
                removeListeners();
                process.nextTick(() => {
                    debug(`Resolving the promise with amqp sender "${rheaSender.name}".`);
                    resolve(sender);
                });
            };
            onClose = (context) => {
                removeListeners();
                debug(`Error occurred while creating a sender over amqp connection.`, context.sender.error);
                reject(context.sender.error);
            };
            rheaSender.once(_1.SenderEvents.sendable, onSendable);
            rheaSender.once(_1.SenderEvents.senderClose, onClose);
        });
    }
    registerHandler(event, handler) {
        this._session.on(event, handler);
    }
    removeHandler(event, handler) {
        this._session.removeListener(event, handler);
    }
    registerConnectionHandler(event, handler) {
        this._connection.registerHandler(event, handler);
    }
    removeConnectionHandler(event, handler) {
        this._connection.removeHandler(event, handler);
    }
}
exports.Session = Session;
//# sourceMappingURL=session.js.map