"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const uuid = require("uuid/v4");
const Constants = require("./util/constants");
const debugModule = require("debug");
const retry_1 = require("./retry");
const rhea_promise_1 = require("../rhea-promise");
const errors_1 = require("./errors");
const debug = debugModule("azure:amqp-common:reqreslink");
class RequestResponseLink {
    constructor(session, sender, receiver) {
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
        this.session = session;
        this.sender = sender;
        this.receiver = receiver;
    }
    get connection() {
        return this.session.connection;
    }
    isOpen() {
        return this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen();
    }
    sendRequest(request, timeoutInSeconds) {
        if (!request) {
            throw new Error("request is a required parameter and must be of type 'object'.");
        }
        if (!request.message_id)
            request.message_id = uuid();
        if (!timeoutInSeconds) {
            timeoutInSeconds = 10;
        }
        const sendRequestPromise = new Promise((resolve, reject) => {
            let waitTimer;
            let timeOver = false;
            const messageCallback = (context) => {
                // remove the event listener as this will be registered next time when someone makes a request.
                this.receiver.removeHandler(rhea_promise_1.ReceiverEvents.message, messageCallback);
                const code = context.message.application_properties[Constants.statusCode];
                const desc = context.message.application_properties[Constants.statusDescription];
                const errorCondition = context.message.application_properties[Constants.errorCondition];
                const responseCorrelationId = context.message.correlation_id;
                debug("[%s] %s response: ", this.connection.id, request.to || "$management", context.message);
                if (code > 199 && code < 300) {
                    if (request.message_id === responseCorrelationId || request.correlation_id === responseCorrelationId) {
                        if (!timeOver) {
                            clearTimeout(waitTimer);
                        }
                        debug("[%s] request-messageId | '%s' == '%s' | response-correlationId.", this.connection.id, request.message_id, responseCorrelationId);
                        return resolve(context.message.body);
                    }
                    else {
                        debug("[%s] request-messageId | '%s' != '%s' | response-correlationId. " +
                            "Hence dropping this response and waiting for the next one.", this.connection.id, request.message_id, responseCorrelationId);
                    }
                }
                else {
                    const condition = errorCondition || errors_1.ConditionStatusMapper[code] || "amqp:internal-error";
                    const e = {
                        condition: condition,
                        description: desc
                    };
                    return reject(errors_1.translate(e));
                }
            };
            const actionAfterTimeout = () => {
                timeOver = true;
                this.receiver.removeHandler(rhea_promise_1.ReceiverEvents.message, messageCallback);
                const address = this.receiver.address || "address";
                const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                    `endpoint timed out. Please try again later.`;
                const e = {
                    condition: errors_1.ConditionStatusMapper[408],
                    description: desc
                };
                return reject(errors_1.translate(e));
            };
            this.receiver.registerHandler(rhea_promise_1.ReceiverEvents.message, messageCallback);
            waitTimer = setTimeout(actionAfterTimeout, timeoutInSeconds * 1000);
            debug("[%s] %s request sent: %O", this.connection.id, request.to || "$managment", request);
            this.sender.send(request);
        });
        return retry_1.retry(() => sendRequestPromise);
    }
    async close() {
        await this.sender.close();
        await this.receiver.close();
        await this.session.close();
    }
    static async create(connection, senderOptions, receiverOptions) {
        if (!connection) {
            throw new Error(`Please provide a connection to create the sender/receiver link on the same session.`);
        }
        if (!senderOptions) {
            throw new Error(`Please provide sender options.`);
        }
        if (!receiverOptions) {
            throw new Error(`Please provide receiver options.`);
        }
        const session = await connection.createSession();
        const sender = await session.createSender(senderOptions);
        const receiver = await session.createReceiver(receiverOptions);
        debug("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
        return new RequestResponseLink(session, sender, receiver);
    }
}
exports.RequestResponseLink = RequestResponseLink;
//# sourceMappingURL=requestResponseLink.js.map