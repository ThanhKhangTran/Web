"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const debugModule = require("debug");
const uuid = require("uuid/v4");
const rhea_promise_1 = require("./rhea-promise");
const eventData_1 = require("./eventData");
const amqp_common_1 = require("./amqp-common");
const linkEntity_1 = require("./linkEntity");
const debug = debugModule("azure:event-hubs:sender");
/**
 * Describes the EventHubSender that will send event data to EventHub.
 * @class EventHubSender
 */
class EventHubSender extends linkEntity_1.LinkEntity {
    /**
     * Creates a new EventHubSender instance.
     * @constructor
     * @param {ConnectionContext} context The connection context.
     * @param {string|number} [partitionId] The EventHub partition id to which the sender
     * wants to send the event data.
     */
    constructor(context, partitionId, name) {
        super(context, { name: name, partitionId: partitionId });
        /**
         * @property {string} senderLock The unqiue lock name per connection that is used to acquire the
         * lock for establishing a sender link by an entity on that connection.
         * @readonly
         */
        this.senderLock = `sender-${uuid()}`;
        this.address = this._context.config.entityPath;
        if (this.partitionId != undefined) {
            this.address += `/Partitions/${this.partitionId}`;
        }
        this.audience = `${this._context.config.endpoint}${this.address}`;
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            const sessionError = context.session.error;
            if (senderError) {
                const err = amqp_common_1.translate(senderError);
                debug("[%s] An error occurred for sender '%s': %O.", this._context.connectionId, this.name, err);
            }
            else if (sessionError) {
                const err = amqp_common_1.translate(sessionError);
                debug("[%s] An error occurred on the session of sender '%s': %O.", this._context.connectionId, this.name, err);
            }
        };
        this._onAmqpClose = async (context) => {
            const senderError = context.sender && context.sender.error;
            const sessionError = context.session.error;
            if (senderError) {
                debug("[%s] 'sender_close' event occurred for sender '%s'. The associated error is: %O", this._context.connectionId, this.address, senderError);
            }
            else if (sessionError) {
                debug("[%s] 'session_close' event occurred for sender '%s'. The associated error is: %O", this._context.connectionId, this.address, sessionError);
            }
            await this.detached(senderError || sessionError);
        };
    }
    /**
     * Sends the given message, with the given options on this link
     *
     * @param {any} data Message to send.  Will be sent as UTF8-encoded JSON string.
     * @returns {Promise<Delivery>} Promise<Delivery>
     */
    async send(data) {
        try {
            if (!data || (data && typeof data !== "object")) {
                throw new Error("data is required and it must be of type object.");
            }
            if (!this.isOpen()) {
                debug("Acquiring lock %s for initializing the session, sender and " +
                    "possibly the connection.", this.senderLock);
                await amqp_common_1.defaultLock.acquire(this.senderLock, () => { return this._init(); });
            }
            const message = eventData_1.EventData.toAmqpMessage(data);
            message.body = this._context.dataTransformer.encode(data.body);
            return await this._trySend(message, message.message_id);
        }
        catch (err) {
            debug("An error occurred while sending the message %O", err);
            throw err;
        }
    }
    /**
     * Send a batch of EventData to the EventHub. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @param {Array<EventData>} datas  An array of EventData objects to be sent in a Batch message.
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    async sendBatch(datas) {
        try {
            if (!datas || (datas && !Array.isArray(datas))) {
                throw new Error("data is required and it must be an Array.");
            }
            if (!this.isOpen()) {
                debug("Acquiring lock %s for initializing the session, sender and " +
                    "possibly the connection.", this.senderLock);
                await amqp_common_1.defaultLock.acquire(this.senderLock, () => { return this._init(); });
            }
            debug("[%s] Sender '%s', trying to send EventData[].", this._context.connectionId, this.name);
            const messages = [];
            // Convert EventData to AmqpMessage.
            for (let i = 0; i < datas.length; i++) {
                const message = eventData_1.EventData.toAmqpMessage(datas[i]);
                message.body = this._context.dataTransformer.encode(datas[i].body);
                messages[i] = message;
            }
            // Encode every amqp message and then convert every encoded message to amqp data section
            const batchMessage = {
                body: rhea_promise_1.message.data_sections(messages.map(rhea_promise_1.message.encode))
            };
            // Set message_annotations, application_properties and properties of the first message as
            // that of the envelope (batch message).
            if (messages[0].message_annotations) {
                batchMessage.message_annotations = messages[0].message_annotations;
            }
            if (messages[0].application_properties) {
                batchMessage.application_properties = messages[0].application_properties;
            }
            for (const prop of rhea_promise_1.messageProperties) {
                if (messages[0][prop]) {
                    batchMessage[prop] = messages[0][prop];
                }
            }
            if (!batchMessage.message_id) {
                batchMessage.message_id = uuid();
            }
            // Finally encode the envelope (batch message).
            const encodedBatchMessage = rhea_promise_1.message.encode(batchMessage);
            debug("[%s] Sender '%s', sending encoded batch message.", this._context.connectionId, this.name, encodedBatchMessage);
            return await this._trySend(encodedBatchMessage, batchMessage.message_id, 0x80013700);
        }
        catch (err) {
            debug("An error occurred while sending the batch message %O", err);
            throw err;
        }
    }
    /**
     * Will reconnect the sender link if necessary.
     * @param {AmqpError | Error} [senderError] The sender error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    async detached(senderError) {
        let shouldReopen = false;
        if (senderError && this._context.senders[this.address]) {
            const translatedError = amqp_common_1.translate(senderError);
            if (translatedError.retryable) {
                shouldReopen = true;
            }
        }
        else if (this._context.senders[this.address]) {
            shouldReopen = true;
            debug("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                "was no accompanying error as well. This is a candidate for re-establishing the sender link.", this._context.connectionId, this.name, this.address);
        }
        if (shouldReopen) {
            await amqp_common_1.defaultLock.acquire(this.senderLock, () => {
                const options = this._createSenderOptions({
                    newName: true
                });
                // shall retry 3 times at an interval of 15 seconds and bail out.
                return amqp_common_1.retry(() => this._init(options));
            });
        }
    }
    /**
     * "Unlink" this sender, closing the link and resolving when that operation is complete.
     * Leaves the underlying connection open.
     * @return {Promise<void>} Promise<void>
     */
    async close() {
        if (this._sender) {
            try {
                const senderLink = this._sender;
                this._sender = undefined;
                delete this._context.senders[this.address];
                clearTimeout(this._tokenRenewalTimer);
                debug("[%s] Deleted the sender '%s' with address '%s' from the client cache.", this._context.connectionId, this.name, this.address);
                await senderLink.close();
                debug("[%s] Sender '%s' with address '%s' closed.", this._context.connectionId, this.name, this.address);
            }
            catch (err) {
                debug("An error occurred while closing the sender '%s' with address '%s': %O", this.name, this.address, err);
                throw err;
            }
        }
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._sender && this._sender.isOpen();
        debug("[%s] Sender '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    _createSenderOptions(options) {
        if (options.newName)
            this.name = `${uuid()}`;
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose
        };
        debug("Creating sender with options: %O", srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to EventHub if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     *
     * @param message The message to be sent to EventHub.
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    _trySend(message, tag, format) {
        const sendEventPromise = () => new Promise((resolve, reject) => {
            debug("[%s] Sender '%s', credit: %d available: %d", this._context.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
            if (this._sender.sendable()) {
                debug("[%s] Sender '%s', sending message: %O", this._context.connectionId, this.name, message);
                let onRejected;
                let onReleased;
                let onModified;
                let onAccepted;
                const removeListeners = () => {
                    this._sender.removeHandler(rhea_promise_1.SenderEvents.rejected, onRejected);
                    this._sender.removeHandler(rhea_promise_1.SenderEvents.accepted, onAccepted);
                    this._sender.removeHandler(rhea_promise_1.SenderEvents.released, onReleased);
                    this._sender.removeHandler(rhea_promise_1.SenderEvents.modified, onModified);
                };
                onAccepted = (context) => {
                    // Since we will be adding listener for accepted and rejected event every time
                    // we send a message, we need to remove listener for both the events.
                    // This will ensure duplicate listeners are not added for the same event.
                    removeListeners();
                    debug("[%s] Sender '%s', got event accepted.", this._context.connectionId, this.name);
                    resolve(context.delivery);
                };
                onRejected = (context) => {
                    removeListeners();
                    debug("[%s] Sender '%s', got event rejected.", this._context.connectionId, this.name);
                    reject(amqp_common_1.translate(context.delivery.remote_state.error));
                };
                onReleased = (context) => {
                    removeListeners();
                    debug("[%s] Sender '%s', got event released.", this._context.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqp_common_1.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.connectionId}] Sender '${this.name}', ` +
                            `received a release disposition.Hence we are rejecting the promise.`);
                    }
                    reject(err);
                };
                onModified = (context) => {
                    removeListeners();
                    debug("[%s] Sender '%s', got event modified.", this._context.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqp_common_1.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.connectionId}] Sender "${this.name}", ` +
                            `received a modified disposition.Hence we are rejecting the promise.`);
                    }
                    reject(err);
                };
                this._sender.registerHandler(rhea_promise_1.SenderEvents.accepted, onAccepted);
                this._sender.registerHandler(rhea_promise_1.SenderEvents.rejected, onRejected);
                this._sender.registerHandler(rhea_promise_1.SenderEvents.modified, onModified);
                this._sender.registerHandler(rhea_promise_1.SenderEvents.released, onReleased);
                const delivery = this._sender.send(message, tag, format);
                debug("[%s] Sender '%s', sent message with delivery id: %d and tag: %s", this._context.connectionId, this.name, delivery.id, delivery.tag.toString());
            }
            else {
                // let us retry to send the message after some time.
                const msg = `[${this._context.connectionId}] Sender "${this.name}", ` +
                    `cannot send the message right now. Please try later.`;
                debug(msg);
                const amqpError = {
                    condition: amqp_common_1.ErrorNameConditionMapper.SenderBusyError,
                    description: msg
                };
                reject(amqp_common_1.translate(amqpError));
            }
        });
        const jitter = amqp_common_1.randomNumberFromInterval(1, 4);
        return amqp_common_1.retry(sendEventPromise, 3, 5 + jitter);
    }
    /**
     * Initializes the sender session on the connection.
     * @returns {Promise<void>}
     */
    async _init(options) {
        try {
            if (!this.isOpen()) {
                await this._negotiateClaim();
                debug("[%s] Trying to create sender '%s'...", this._context.connectionId, this.name);
                if (!options) {
                    options = this._createSenderOptions({});
                }
                this._sender = await this._context.connection.createSender(options);
                this._sender.setMaxListeners(1000);
                this._sender.registerSessionHandler(rhea_promise_1.SessionEvents.sessionError, this._onAmqpError);
                this._sender.registerSessionHandler(rhea_promise_1.SessionEvents.sessionClose, this._onAmqpClose);
                debug("[%s] Promise to create the sender resolved. Created sender with name: %s", this._context.connectionId, this.name);
                debug("[%s] Sender '%s' created with sender options: %O", this._context.connectionId, this.name, options);
                // It is possible for someone to close the sender and then start it again.
                // Thus make sure that the sender is present in the client cache.
                if (!this._context.senders[this.address])
                    this._context.senders[this.address] = this;
                await this._ensureTokenRenewal();
            }
        }
        catch (err) {
            err = amqp_common_1.translate(err);
            debug("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name, err);
            throw err;
        }
    }
    /**
     * Creates a new sender to the given event hub, and optionally to a given partition if it is
     * not present in the context or returns the one present in the context.
     * @static
     * @param {(string|number)} [partitionId] Partition ID to which it will send event data.
     * @returns {Promise<EventHubSender>}
     */
    static create(context, partitionId) {
        if (partitionId && typeof partitionId !== "string" && typeof partitionId !== "number") {
            throw new Error("'partitionId' must be of type: 'string' | 'number'.");
        }
        const ehSender = new EventHubSender(context, partitionId);
        if (!context.senders[ehSender.address]) {
            context.senders[ehSender.address] = ehSender;
        }
        return context.senders[ehSender.address];
    }
}
exports.EventHubSender = EventHubSender;
//# sourceMappingURL=eventHubSender.js.map